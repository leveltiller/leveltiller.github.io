<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[windows下使用hexo创建博客(总结、学习)]]></title>
    <url>%2F2019%2F07%2F10%2Fwindows%E4%B8%8B%E4%BD%BF%E7%94%A8hexo%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E6%80%BB%E7%BB%93%E3%80%81%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[初始准备第一步安装node.js：傻瓜式安装，使用node-v npm-v测试（需重新打开cmd窗口） 第二步安装淘宝镜像npm install -g cnpm –registry=https://registry.npm.taobao.org可以cmd窗口中使用cnpm 或 cnpm -v 测试 第三步使用cnpm全局下安装hexo命令：cnpm install -g hexo-cli在cmd中使用hexo-v测试 使用hexo正式搭建博客第一步 建立一个空文件夹 cmd命令： C:\Users\DELL&gt;cd E:\hexobokeC:\Users\DELL&gt;e:E:\hexoboke&gt;mkdir blogE:\hexoboke&gt; 如果博客搭建过程中出现问题，可以将blog删掉重来进入blog文件夹： E:\hexoboke&gt;cd blog/E:\hexoboke\blog&gt; 第二步初始化一个博客这里我打开了git bash命令行： $ cd /E/hexoboke/blog$ hexo init 这里我因为在执行过程中ctrl+c强制结束了，所以可能有错，将blog下的内容删掉后发现，再次执行hexo init出现 file not empty的报错。经查找后发现，里面有一个隐藏文件，在我的电脑该文件夹下选中查看选项卡（位置在三四个），然后勾中隐藏的项目即可。第一次弄的时候卡住了，很长时间都没反应，换了一个core-js版本 12// 这步完成的标志：git bash显示INFO Start blogging with Hexo! $ ls -ltotal 165-rw-r–r– 1 DELL 197121 1846 7月 4 19:16 _config.ymldrwxr-xr-x 1 DELL 197121 0 7月 4 19:18 node_modules/-rw-r–r– 1 DELL 197121 462 7月 4 19:16 package.json-rw-r–r– 1 DELL 197121 114373 7月 4 19:18 package-lock.jsondrwxr-xr-x 1 DELL 197121 0 7月 4 19:16 scaffolds/drwxr-xr-x 1 DELL 197121 0 7月 4 19:16 source/drwxr-xr-x 1 DELL 197121 0 7月 4 19:16 themes/ 第三步 启动服务器 $hexo sINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 第四步 浏览器预览 http://localhost:4000 第五步 新建一篇博客文章 先ctrl+c退出预览 $ hexo n “Integer与int的比较与区别”INFO Created: E:\hexoboke\blog\source_posts\Integer与int的比较与区别.md 命令不要写错 第六步 写文章 可以用 $cd source/_posts/$ vim Integer与int的比较与区别.md 来写我用的Notepad++打开之后的文字是这样的： - - -title: Integer与int的比较与区别date: 2019-07-04 19:35:58tags:- - - 然后在后面用markdown语法编写博文内容 第七步 如果不在blog文件夹下需要切换回去 使用 … 清除缓存文件 (db.json) 和已生成的静态文件 (public) $ hexo clean 第八步 生成静态文件 $ hexo g INFO 29 files generated in 699 ms 第九步 重新启动服务器 $hexo s 访问http://localhost:4000关于markdown的==样式和&gt;样式显示不出来的问题我们慢慢解决 将项目部署到gitHub上第一步 新建仓库 new repository 我的是 Owner Repository nameleveltiller /leveltiller.github.io 用户部署个人博客的github仓库的命名必须是你的用户名.github.io 第二步在blog文件夹下 安装部署插件 $ cnpm install –save hexo-deployer-git 显示完成： √ All packages installed (174 packages installed from npm registry, used 11s(network 10s), speed 295.5kB/s, json 156(299.29kB), tarball 2.54MB) 第三步 更改配置文件，blog文件夹下_config.yml 同样使用notepad++ 拉到文本末尾，找到deploy: deploy:&emsp;&emsp; type: git&emsp;&emsp; repo: http://github.com/leveltiller/leveltiller.github.io.git&emsp;&emsp; branch: master ：后面要加空格repo内容为新建的那个仓库名 第四步 部署到远端 git bash hexo d 期间会让登录github，输入账号和密码执行完成，显示 To http://github.com/leveltiller/leveltiller.github.io.git* [new branch] HEAD -&gt; masterBranch ‘master’ set up to track remote branch ‘master’ from ‘http://github.com/leveltiller/leveltiller.github.io.git&#39;.INFO Deploy done: git 进入博客 在浏览器输入项目名如：leveltiller.github.io 此时我的博客如图：听说这步如果不成功可能是因为git环境变量没配好？github ssh公钥？git用户名和github用户名不一样 更换主题第一步来到https://github.com/litten/hexo-theme-yilia观摩一下 第二步下载主题git bash blog文件夹下,将主题下载到themes/yilia下 $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 完成后显示 Resolving deltas: 100% (1093/1093), done. 第三步再次修改blog文件夹下的_config.yml文件找到其中的 # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 修改为： # Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia 第四步git bash下重新清理一下 $ hexo cleanINFO Deleted database.INFO Deleted public folder. 重新生成一下 $ hexo g 重新启动一下 $ hexo s 访问http://localhost:4000可发现主题已替换 第五步推到远端ctrl+c结束运行 hexo d 完成后显示 INFO Deploy done: git 在浏览器中访问https://leveltiller.github.io/即可看到改变 结束语一个没有经过美化和修改的初始博客就这样完成了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Integer与int的比较与区别————学习总结]]></title>
    <url>%2F2019%2F07%2F04%2FInteger%E4%B8%8Eint%E7%9A%84%E6%AF%94%E8%BE%83%E4%B8%8E%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[如题： 123456789101112Integer a = new Integer(3);Integer b = 3;int c = 3;System.out.println(a == b);System.out.println(a == c); Integer f1 = 100, f2 = 100;Integer f3 = 200;Integer f4 = 200;System.out.println(f1 == f2);System.out.println(f3 == f4);System.out.println(f3 == (f1 + f2)); 结果：a==b的答案是：false无论如何，Integer与new Integer不会相等。不会经历拆箱过程，Integer的引用指向堆，而new Integer指向专门存放他的内存（常量池），他们的内存地址不一样，所以为false 原因很简点，因为对与对象来说 “==” 判断的依据是两个对象的地址是否相等，显然a是新建的对象和b自动包装出来的堆相指向的不是同一个地址，所以为false。 a==c的答案是：true包装类Integer和基本类型的数据在比对时会自动拆箱（调用Integer的intValue()方法）进行比较。int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比。 因为c是一个基本类型的数据，包装类Integer和基本类型的数据在比对时会自动拆箱（调用Integer的intValue()方法）进行比较，即使用a对象的数值和基本类型c进行数值大小的比较。 f1 == f2 的答案是：truef3 == f4 的答案：false两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false java在编译Integer x = 1的时候,被翻译成-&gt; Integer x = Integer.valueOf(1);JDK源码的valueOf函数式这样的： 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; //判断是否在缓存数组里，如果在，直接返回 return new Integer(i);//不在缓存的数组里，直接new一个新的对象返回 &#125; 看一下IntegerCache这个类： 123456789101112131415161718192021222324252627282930313233 private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123;//检查虚拟机中有没有相应的配置，如果有取该值和默认值的最大值；如果没有取默认值 try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1];//创建缓存数组，并给数组初始化值 int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125; 这是一个内部静态类，该类只能在Integer这个类的内部访问，这个类在初始化的时候，会去加载JVM的配置，如果有值，就用配置的值初始化缓存数组，否则就缓存-128到127之间的值。 f3==(f1+f2)的答案：trueInteger对象之间在执行符号运算时，会自动拆箱，（调用Integer的intValue()方法） 因为Integer对象之间在执行符号运算时，会自动拆箱，（调用Integer的intValue()方法）,所以f1+f2是其对象数值的相加，得到的结果是int类型的200，此时再次和f3进行比较，因为200是int类型的基本类型数据，所以f3也会进行自动拆箱，和之前运算得到的200进行比较，值相等，结果为true。 下面附上编译后的字节码文件（已经进行过反编译）： 123456789101112131415Integer a = new Integer(3);Integer b = Integer.valueOf(3);int c = 3; System.out.println(a == b);System.out.println(a.intValue() == c); Integer f1 = Integer.valueOf(100);Integer f2 = Integer.valueOf(100);Integer f3 = Integer.valueOf(200);////这个相当于new了两个对象，==比较的是引用变量的内存地址，所以为falseInteger f4 = Integer.valueOf(200); System.out.println(f1 == f2);System.out.println(f3 == f4);System.out.println(f3.intValue() == f1.intValue() + f2.intValue()); 两个Integer对象都是new出来的,都为false]]></content>
      <categories>
        <category>Java</category>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
